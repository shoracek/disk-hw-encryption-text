\appendix


\chapter{Usage of tools}
\label{appendix:usage}

Before the tools can be used, they need to be compiled first. Part of the project is a \verb|Makefile|, which allows a simple compilation of all the necessary project files by executing the \verb|make| command. Since the code is designed to be self-sufficient, it is not necessary to install any other packages than the build tools. Afterwards, the tools are ready to be used.
Note that in order for the tools to work correctly, they must be used with Opal-compliant disks. 

Currently, only NVMe and SATA disks are supported. SATA disks require \verb|libata.allow_tpm| option to be set. If this option is not set, a workaround using SCSI commands is used. However, this does not work well for all SATA disks.

In these few following sections, short documentation on the usage of the CLI tools implemented in this thesis can be found.

\section{Usage of \texttt{rng} utility}

The \verb|rng| allows to access the generated by RNG of an Opal-compliant disk.
This utility accepts the file of the device as the first argument. This file is usually \verb|/dev/sda|, \verb|/dev/nvme0|, or similar.
Optionally, the number of bytes per one session, number of sessions, and the level of logging, in this order, can be used as the next arguments.
The output is one or more lines of random bytes represented in hexadecimal. Each line represents a separate session. The invocation and the output of this utility can be seen in Listing~\ref{lst:rng_def}, Listing~\ref{lst:rng_one}, and Listing~\ref{lst:rng_two}.

% \begin{lstlisting} 
% [root@the-machine-with-disks code]# ./rng
% Usage: ./rng <device> [bytes [repeats]]

% Bytes are acquired in chunks of 32 bytes.
% Each repeat is a separate session.
% \end{lstlisting}

\begin{lstlisting}[caption=Execution with default arguments,label={lst:rng_def}]
# ./rng /dev/nvme0
65d3e1e12edb77f9aa82014a8472b7028841758fee50b...
\end{lstlisting}

\begin{lstlisting}[caption=Execution specifying number of bytes per session,label={lst:rng_one}]
# ./rng /dev/nvme0 16
52c6bd17664b9eef860186a05e4ecf19
\end{lstlisting}

\begin{lstlisting}[caption=Execution specifying number of sessions,label={lst:rng_two}]
# ./rng /dev/nvme0 16 4
2e42ac614b333a5b154e46b1f4c0e491
f7793cb0a8912cbbc8012927e5a64e10
57b5137fa729f7868f8e1639de84b7b4
7cede41adf9af1a17cbc350ef3a8387f
\end{lstlisting}



\section{Usage of \texttt{discovery} utility}

The \verb|discovery| provides a way to print parameters of Opal-compliant disks. Similarly to the \verb|rng| utility, this utility accepts the file of the device as the first argument. The next arguments are the selection of information and the logging level. The selection of information allows to limit the output to only its subset. Depending on the value the output may be limited to either only metainformation (containing output format versioning), output of identify commands, any Discovery level, or a few random bytes. Usage and output of this utility may be seen in Listing~\ref{lst:discovery_all} and Listing~\ref{lst:discovery_some}.

% \begin{lstlisting}[caption=]
% # ./discovery
% Usage: ./discovery <device> [selection [log_level]]

% selection: 0=everything,
%            1=metainformation,
%            2=identify,
%            3=level 0 discovery,
%            4=level 1 discovery,
%            5=level 2 discovery,
%            6=level 2 discovery - extra,
%            7=rng
% log:       0=error,
%            1=info,
%            2=everything
% \end{lstlisting}


\begin{lstlisting}[caption=Execution providing entire output,label={lst:discovery_all}]
# ./discovery /dev/sdc
{
"Metadata": {
  "Version": "1"
},
"Identify": {
  "Serial number": "S2BENCAHC05716J   ",
  "Firmware version": "EXM04B",
  "Model number": "Samsung SSD 850 PRO 512GB             "
},
"Discovery 0": {
  "TPer Feature": {
    "Version": 1,
    "ComID Mgmt Supported": 0,
    "Streaming Supported": 1,
    "Buffer Mgmt Supported": 0,
...
\end{lstlisting}

\begin{lstlisting}[caption=Execution limited to Level 1 Discovery information,label={lst:discovery_some}]
# ./discovery /dev/sdc 4
{
"Discovery 1": {
  "Properties": {
    "MaxComPacketSize": "0x010200",
    "MaxResponseComPacketSize": "0x010200",
    "MaxPacketSize": "0x0101ec",
    "MaxIndTokenSize": "0x0101c8",
    "MaxPackets": "0x01",
    "MaxSubpackets": "0x01",
    "MaxMethods": "0x01",
    "MaxAuthentications": "0x05",
    "MaxSessions": "0x01",
    "MaxTransactionLimit": "0x01",
    "DefSessionTimeout": "0x00"
  }
}}

\end{lstlisting}


\section{Usage of \texttt{control} utility}

The \verb|control| utility allows to manage Opal-compliant disks. Since it contains many more distinct commands compared to the previous two tools, its invocation is more complex. 
% In Listing~\ref{lst:control_help} the usage of this utility may be seen. 
Each command requires the disk file to be specified and also one or more of options specific to the command. In Listing~\ref{lst:control_workflow} an example of possible usage during a life cycle of the disk may be seen, with comments describing each step.

% \begin{lstlisting}[language=bash,caption=Help output,label={lst:control_help}]
% # ./control --help
% Usage: control [OPTION...] device command
%         device               File of Opal-compliant disk
%         command              One of the commands defined further

%   -V, --verbose

%  regenerate_key - Re-generate of a locking range
%       --locking-range=id     Locking range to re-generate
%       --verify-pin=hex_pin   Password of Admin1 authority

%  psid_revert - Revert the device to factory state
%       --verify-pin=hex_pin   PSID

%  setup_tper - Take ownership over the device
%       --assign-pin=hex_pin   Password to assign to the owner authority

%  setup_user - Enable a user
%       --assign-pin=hex_pin   Password to assign to selected user authority
%       --user=id              ID of the user authority
%       --verify-pin=hex_pin   Password of Admin1 authority

%  setup_range - Configure a locking range
%       --locking-range=id     Locking range to change
%       --locking-range-length=length
%       --locking-range-start=position
%       --user=id              User to have control over the locking range (can
%                              be repeated)
%       --verify-pin=hex_pin   Password of Admin1 authority

%  unlock - Lock or unlock a locking range
%   -a, --admin=id             Admin authority to authenticate as
%   -l, --locking-range=id     Locking range to lock/unlock
%       --read-locked=state
%   -u, --user=id              User authority to authenticate as
%   -v, --verify-pin=hex_pin   Password of the authority
%       --write-locked=state

%   -?, --help                 Give this help list
%       --usage                Give a short usage message

% \end{lstlisting}

\begin{lstlisting}[language=bash,caption=Workflow,label={lst:control_workflow}]
# Take ownership over the device, activating 
# the Locking SP and assigning pin to the 
# Admin authority.
./control setup_tper /dev/sdd                  \
    --assign-pin 0000
# Create two users, each with their own
# password.
./control setup_user /dev/sdd                  \
    --verify-pin 0000                          \
    --user 1 --assign-pin 1111
./control setup_user /dev/sdd                  \
    --verify-pin 0000                          \
    --user 2 --assign-pin 2222
# Enable first locking range and allow the 
# two users to unlock it.
./control setup_range /dev/sdd                 \
    --verify-pin 0000 --locking-range 1        \
    --locking-range-start 0                    \ 
    --locking-range-length 512                 \
    --user 1 --user 2
# Lock the locking range as User1.
./control unlock /dev/sdd                      \
    --user 1 --verify-pin 1111                 \
    --locking-range 1 --read-locked 1
# Unlock the locking range as User2.
./control unlock /dev/sdd                      \
    --user 2 --verify-pin 2222                 \
    --locking-range 1 --read-locked 0
# Finally, revert the disk to factory state.
./control psid_revert /dev/sdd                 \
    --verify-pin ${PSID}
\end{lstlisting}

\chapter{Patterns in disk content}
\label{appendix:rng_pattern}

When data is encrypted using symmetric cipher under CBC mode with one key and decrypted with another, the result should be random.
However, this is not the case with one of the disks we tested. Using this approach, SanDisk X300s contains data that may at first sight seem random, but after a deeper analysis, some patterns can be found.

In order to analyse the data present on the Opal disk after the DEK is re-generated, we used our utility \verb|repeat_finder.py|. This simple tool iterates a file and finds repeating chunks of data. In our case, each chunk was 2048 bytes long. Each repeating chunks is printed as list of its locations, divided by the chunk size. An example of part of this output can be seen in Figure~\ref{fig:rng_pattern_fig}. In this concrete example, there are two patterns we can see.

\begin{lstlisting}[caption={Found patterns on zeroed disk},label={fig:rng_pattern_fig},language=Python]
[0, 128, 32432]
[1, 3, 5, 7, 9, 11, 13, 15]
[2, 130, 32434]
[4, 132, 32436]
[6, 134, 32438]
[8, 136, 32440]
[10, 138, 32442]
[12, 140, 32444]
[14, 142, 32446]
[16, 32672]
[17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55]
[18, 32674]
    \end{lstlisting}
The first pattern can be seen on the first line, where the chunk repeats after 128 and 32432 chunks, and the pattern repeats several times for even locations. This pattern continues on throughout the entire analysed file, changing the value of the repeated bytes and the offsets and number of  repeats  once in a while.
The second pattern can be seen on the second line, where the chunk is located in every odd location. This pattern continues on throughout the entire analysed file, changing the value of the repeated bytes once in a while.

It should be noted that such patterns emerged only when the disk contents were overwritten with a repeating bytes, such as all zeroes. After repeating the writing of repeating bytes and regenerating of the DEK, the patterns changed. 

However, it is enough for two chunks to be the same. The Listing~\ref{fig:rng_pattern_fig_some} contains the patterns acquired from a disk that had its content randomized, except for two chunks. The bytes in fourth chunk were the same as the bytes in tenth chunk, an evidence of this can be seen in the listing.

\begin{lstlisting}[caption={Found patterns on disk with two same chunks},label={fig:rng_pattern_fig_some},language=Python]
[0]
[1]
[2]
[3, 9]
[4]
[5]
[6]
[7]
[8]
[10]
[11]
[12]
\end{lstlisting}


The source code of the utility and few of the outputs can be found in the attachments.


% \chapter{Patterns in disk content}
% \label{appendix:rng_pattern}
