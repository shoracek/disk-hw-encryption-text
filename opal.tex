\chapter{TCG Opal 2.0}

TCG Opal Security Subsystem Class (SSC) 2.0 (hereinafter referred to simply as ``Opal'') is a specification for storage devices, aiming to provide confidentiality of stored data while the conforming disk is turned off~\cite{tcg-opal2}. It is one of the representatives of the self-encrypting drive approach to hardware disk encryption.

Developed in 2012 by Trusted Computing Group (TCG) as a successor of Opal 1.0.

Information for this chapter comes primarily from the Opal standards, that is the Core standard~\cite{tcg-storage-core} and the Opal standard~\cite{tcg-opal2}.

\section{Structure of the standard}

The Opal 2.0 standard is defined as a subsystem extending the TCG Storage Architecture Core Specification standard. The TCG Storage Architecture Core Specification standard~\cite{tcg-storage-core} specifies the core features and properties shared among several different types of storage security subsystems, that extend the core functionality by specifying additional features or define the set of mandatory features. Each of these subsystems is focused on a different use case. These subsystems are namely: \begin{itemize}
    \item Opal --- targeted at a corporate and personal usage. Described more closely in the rest of this chapter.
    \item Opalite --- simplified Opal. Does not mandate features such as locking ranges, decreases the minimal number of admin and user authorities~\cite{tcg-opalite}. % smaller datastore also, i think
    \item Pyrite --- encryption-less Opalite. Similar to Opalite, however it does not mandate encryption, and instead may offer only logical access control~\cite{tcg-pyrite}.
    \item Ruby --- focused on data centers and server drives. Offers only global range encryption, weaker configuration of access control, no pre-boot authentication support~\cite{tcg-ruby}. Replacing the older Enterprise subsystem.
\end{itemize}

\section{Architecture}

The standard defines several parts of the trusted device.

\subsection{Trusted Peripheral}

Trusted peripheral (TPer) is a device located on the disk that provides the security of the data on disk. A TPer consists of multiple Security Providers.

\subsection{Security Provider}

Security Provider (SP) is defined as a set of tables, methods and an access control. Each SP is derived from a set of templates. These templates define a set of the tables and methods, aimed at one functionality, subset of which the SP implements. The templates are described more closely in later chapter \ref{TODO}.
The Opal 2.0 standard defines that at least the Admin SP and Locking SP must be present in the TPer. The Admin SP tasked with administrating the TPer and other SPs, which may include creating new SPs, deleting existing SPs, or providing information about SPs. The Locking SP provides access to functionality such as managing locking ranges, locking the drive, or managing access control. Both of these SPs are described more closely in later chapter \ref{TODO}.

\section{Capability discovery}

In order to find out the properties and features of a particular device, there exists the so called Discovery process. This process is divided into three levels, each with different reported information and a different approach to access the information.

\subsection{Level 0 discovery}

Level 0 discovery provides basic information about the secure device, and is performed using only the secure send and secure receive commands of the device. The information is provided through feature descriptor. The presence of the feature descriptor header means that the feature is supported and the fields of the header describe the basic properties of that feature.

Some of the features described by these descriptors are the TPer feature (supported communication features such as ack/nack support, comid managment, buffer managment, async communication, ...), Locking (whether disk is locked, etc.), Geometry feature (parameters of the disk, such as block size), Opal V1.0 feature, SingleUser feature (...), DataStore (size of the table), OPAL 2.0 feature (base ComID, number of ComIDs, default pin, number of locking users/admins).

\subsection{Level 1 discovery}

Level 1 discovery provides more thorough information about the TPer, and is performed using the \verb|Properties| control session method.
The reported properties mandatory for Opal are:
\begin{itemize}
\item \verb|MaxMethods| --- maximum number of methods per received subpacket. Default value is 1.
\item \verb|MaxSubpackets| --- maximum number of subpackets per received packet. Default value is 1.
\item \verb|MaxPacketSize| --- maximum size of a received packet. Default value is 1004.
\item \verb|MaxPackets| --- maximum number of packets per received compacket. Default value is 1.
\item \verb|MaxComPacketSize| --- maximum size of a received compacket. Default value is 1024.
\item \verb|MaxResponseComPacketSize| --- maximum size of sent compacket.
\item \verb|MaxSessions| --- maximum number of active sessions.
\item \verb|MaxIndTokenSize| --- maximum size of an individual token. Default value is 968.
\item \verb|MaxAuthentications| --- maximum possible authenticated authorities.
\item \verb|MaxTransactionLimit| --- 
\item \verb|DefSessionTimeout|, --- 
\end{itemize}

There are also defined properties which are optional for Opal:
\begin{itemize}
\item \verb|MaxReadSessions| --- maximum number of reader sessions.
\item \verb|MaxAggTokenSize| --- maximum size of a combined token. Default value is 968.
\item \verb|MaxSessionTimeout| --- 
\item \verb|MinSessionTimeout| --- 
\item \verb|DefTransTimeout| --- 
\item \verb|MaxTransTimeout| --- 
\item \verb|MinTransTimeout| --- 
\item \verb|MaxComIDTime| --- timeout for ComID.
\item \verb|ContinuedTokens| --- . Default value is False.
\item \verb|SequenceNumbers| --- . Default value is False.
\item \verb|AckNak| --- . Default value is False.
\item \verb|Asynchronous| --- . Default value is False.
\end{itemize}

Other than the defined properties, this discovery process may also report other, vendor specific, properties.

\subsection{Level 2 discovery}

Level 2 discovery is the act of reading any table and is provided by the \verb|Get| method of an SP. This includes reading any table, such as the access control table or table of locking ranges. Some of the SPs' tables are described in later chapter~\ref{TODO}.


\section{Life cycle}

In order to keep information about the state and the working capacity of an SP, the concept life cycle is introduced. Life cycle describes the condition of an SP using one of several states. In the Core standard the following states are introduced: 
\begin{itemize}
\item ``nonexistent'' --- the SP does not exist because it either was not created yet, or was already deleted.
\item ``issued'' --- the SP is in functional state.
\item ``issued-disabled'' --- the SP can only be authenticated to and enabled, all other functionality is disabled. An SP can be enabled and disabled using the SPInfo table of the corresponding SP.
\item ``issued-frozen'' --- no functionality of the SP is enabled. An SP can be frozen and unfrozen using the SP table of the Admin SP.
\item ``issued-disabled-fronzen'' --- the SP is both disabled and frozen as described in the two previous points.
\item ``issued-failed'' --- SP is in fatal failure from which it cannot recover.
\end{itemize}

\subsection{SP Issuance}

SP issuance is the process of creation of a new SP from a base template and a set of other templates. After an SP is issued, it can be personalized. Personalization of an SP is the process of filling in tables, setting up authorities and access control.

\subsection{Life cycles in Opal}

Opal extends the states defined in the Core specification with a new set of life cycle states called ``manufactured'' --- ``manufactured-inactive'', ``manufactured'', ``manufactured-failed'', ``manufactured-disabled'', ``manufactured-disabled-frozen'', ``manufactured-disabled''. Each of these new states mirrors the corresponding ``issued'' state from Core specification. However, compared to the ``issued'' states, the ``manufactured'' states are created during manufacturing by the manufacturer, instead of during the subsequent use by the TPer owner. Because of this, the SPs are not issued and deleted in Opal, instead they are activated and reverted. Activation skips the process of personalization and the deletion maintains the existence of the SP. Note that this means that the ``manufactured-inactive'' corresponds to the ``nonexistent'' state.


\section{Communication}

In order to send commands to the TPer or the SPs and receive responses, a specific protocol must be used. % TODO: Rephrase this...
The protocol is split into several layers. The high level method calls, optional transactions, and sessions, which are carried by the interface commands.
((It's actually session, management, communication, TPer, interface, transport, in different part, fixup TODO.))

One of the information required in order to send a command is the ComID, a number identifying the caller (e.g. application of the host). It ensures that responses to method calls will be received by the correct application, since there can be at one time multiple callers. This number can be acquired through the level 0 discovery process.

The communication is based on packets. ComPacket is the primary one, each ComPacket contains data for communication under only a single ComID. Each ComPacket can contain several Packets. The usage of Packet is intended for session reliability, specifying sequential numbers and the acknowledgements for them. Every Packet then consists of one or more SubPackets. Finally, SubPacket contains one or more method calls, or results of method calls.


\subsection{Method calls}

The data of the SubPacket carries either the method call or method response. %can't there be something else?
These are expressed using a set of tokens in a specific order.

structure is: \\
\verb# CALL_TOKEN | OBJECT_UID | METHOD_UID# \\
\verb#| START_LIST_TOKEN | ARGUMENTS | END_LIST_TOKEN | END_OF_DATA_TOKEN# \\
\verb#| START_LIST_TOKEN | ERROR_VALUE | END_LIST_TOKEN | #

The general structure of response is identical to the structure of call, with different arguments used as a way of passing back information.

object uid can be SP, table, row of table of a special object uid SMUID --- session manager, used for session management

mandatory arguments: \\
\verb#  #

optional arguments: \\
\verb# START_NAME_TOKEN | ARGUMENT_ID | ARGUMENT_VALUE | END_NAME_TOKEN # 


\subsection{Sessions}

Whereas ComID is used to differentiate the senders and therefore also the recipients of the methods, session is used for parallelization of communication of one such actor. Each session can have different authorized authorities and methods in process, but each session is still bound to one ComID. Since each ComID corresponds to one user, both the user and the TPer can send multiple methods calls or responses in one ComPacket.

TODO: not user or actor but host... e.g.  if it would be network storage, there can be some thingie that would split the communication 

Sessions are using system of readers-writer locks, to enable several concurrently running read sessions without causing concurrency issues.

There are two types of sessions: regular and control (not going to care about control much, just between TPer session manager and host session manager)...
Each ComID has one associated control session with lifespan same as the ComID. 

The control session is used for managing the regular sessions and as such provides methods such as:
\begin{itemize}
\item The \verb|properties| method enables to find compromise between the communication capabilities of the host and the TPer, or to simply find the communication capabilities of the TPer. Using this method the properties such as maximum packet size are established.
\item The \verb|start session| and \verb|sync session| methods provide a way to start an unencrypted session.
\item The \verb|start trusted session| and \verb|sync trusted session| methods provide a way to start an encrypted session, after an unencrypted session has been established. The encrypted session provides secure messaging
\item The \verb|close session| method
\end{itemize}


*trustedsession - used with PuK, SymK, and HMAC authorities, secure messaging



TODO: talk about ComID lifecycle


\subsection{Transactions}

In order to facilitate safe execution of sequences of methods, the standard specifies transactions. Similarly to transactions in database systems, this feature enables one to revert effects of sequence of methods. This is done automatically in case the transaction is not finished, or if the transaction is manually aborted. However, not all the effects of methods are rolled back, such as logs. Nested transactions are supported, in which case the transaction is committed when the outermost transaction is finished.


\subsection{Optional features}

Note that some of the features described in the previous sections are optional. Even though every Opal device supports sessions, the minimum required maximum number of sessions is 1, ...

From our experience with Opal disks, most of them implemented only the required minimum <TODO: fact check later on>.

Note that even though in the previous sections it is said that there can be multiple methods per subpacket, or ... these features are all optional. Opal mandates only at least 1 sessions, 1 method per packet, 1 transaction, 1 packet per compacket, 1 subpacket per packet, and so on.





Even though the protocol specifies and can support many features such as secure messaging, asynchronous communication, or session reliability, these features are not mandatory for the Opal subsystem.

\section{Features}

move probably under templates,,, or even better SP?

\subsection{Single User Mode}

In many cases it might be desirable to prevent admins to access user data, even though the admins have generally more competence. In Opal this can be achieved using the Single User Mode~\cite{tcg-sum}. 
After activating Single User Mode, only a single User authority is capable of changing their authority object (this includes changing their PIN, ), changing the LR proprieties (which includes the lock state of the LR), generate new key for the LR.
The only action available to the admins are destructive actions.

% feature set that ``locks'' the admin out --- admin can do only destructive actions upon the locking range, and only the user can actually unlock it

\subsection{MBR shadowing}

This feature enables the disk to provide a fake master boot record (MBR). Instead of the MBR saved on the disk, the disk instead provides the saved shadow MBR on bootup. The shadow MBR may contain a software to authenticate the user to the disk and unlock it. After the shadow MBR is used, it can be deactivated by setting MBR done field in the MBRControl table.

The minimal maximum size of the shadow MBR seems to be 0x08000000 bytes ($\sim$134 MB).

Move to locking SP.


\subsection{Access Control}

In order to provide access to methods only to authorized actors, the standard also defines access control. The access control provides a way to allow access to methods of the SP only after a knowledge of a secret has been proved. Information required to verify knowledge of the secret is called a credential and is stored in one of the corresponding SP's credential table. Each SP may contain several credential tables, one for each type of credential, such as pin, RSA key pair, or AES key.

In order to support authentication of more than one user or require multiple users at once access control rules are defined using Access Control Lists (ACL) containing Access Control Elements (ACE). Each entry in an ACL has an owner \dots. ACEs are Boolean expressions with inputs being authentication of authorities.


% Access control -- access control list consists of access control elements (boolean combination of authorities),,,
% each SP has AdminExch authority,,, 
% ACEs seem to be able to have different "owners",,,

Other than an explicit authentication, an implicit authentication is also possible. In this authentication, the knowledge of secret is shown by successfully using encrypted communication channel. FACT CHECK

Each authority is an object in the authority table of the corresponding SP.
Each authority has a type which is either individual or class. Clas authorities correspond to a set of authorities, so that they can be easily assigned and changed in bulk.

Other than the Admin and User authorities there is also a special SID authority. This authority represents the owner of the TPer, and as such provides access of admins extended by the capabilities related to TPer managment such as the ability to activate an SP or enabling Admin authorities. Compared to the other authorities, SID authority is shared between all SPs.

\section{Templates}

Since SPs may share some of their functionality such as authentication, modification of tables, or retrieval of data from tables, there exists templates to define this shared functionality. Each of the SP then implements a subset of functionality of one or more templates.

\subsection{Base template}

The base template defines the shared subset required by every SP, and is therefore mandatory. The most important functionality that is defined by this template is access control.

\subsection{Admin template}

Template specific for the unique Admin SP. Provides access to methods managing the TPer.

\subsection{Crypto template}

Template providing methods providing cryptographic methods.

\subsection{Locking template}

Template specific for the unique Locking SP. Provides access to methods managing the lock state of the device, locking ranges...

\subsection{Clock template}

Template providing methods for indicating current time, measuring lag, and access to monotonic counter. 

\subsection{Log template}

Template providing methods for logging activity. The logging can be either carried out manually by an user (or an user application) or automatically by the TPer (as a result of invocations of methods of SPs containing this template, including invocations during read-only sessions). 
Only one system log table may exist on each SP, but multiple user log tables may be present on one SP.
The logs are saved on non-volatile storage, depending on the security setting of the table, they may be either buffered or be saved after each entry.

TODO: how much are the logs preserved... will they get deleted with an SP?

\section{Admin SP}

holds information about the TPer and SPs, allows modification/creation/deletion of other SPs

unique

\subsection{Methods}

\section{Locking SP}

Locking SP procures the disk encryption and the locking and unlocking associated with it. This means that it provides access to manipulation of locking ranges, key generation and ...

unique

\subsection{Locking range}

The locking range feature gives the user a way to specify an LBA range on the disk that can be locked independently on the rest of the disk. Each locking range has also it's own ACE, to control who can lock and unlock the range, and it's own DEK.

There also always exists a special range called global locking range that is covering any area on disk that is not already covered by a regular locking range.

\section{Implementations/Direct usage/something like this}


\subsection{Linux ioctl}

Since version 4.11 Linux offers an ioctl requests to facilitate control over an Opal disk. Although these ioctl requests offer a simple access to control of the disk, not every feature is implemented. Some of the limitations are the following: 
\begin{itemize}
\item Offers access to only 1 admin authority and up to 9 user authorities.
\item no "write only" lock
\item only basic binary table read (e.g. no iterations, no structured tables)
\end{itemize}

The individual requests for Opal functionality and their function are:
\begin{itemize}
\item \verb|SAVE| --- adds a key for a locking range into a unlock list, so that it can be used after waking the disk up from suspend. To wake the disk up, exported symbol \verb|opal_unlock_from_suspend| can be used to unlock the disk with the saved data. Note that the data is saved only in the RAM, and so this cannot be used to wake the computer.
\item \verb|LOCK_UNLOCK| --- locks or unlocks reading or writing for the selected locking range.
\item \verb|TAKE_OWNERSHIP| --- changes the admin authority password from the default one to the selected one. TODO: write about initialisation of the TPer to the generic chapter, \verb|C_PIN_MSID| etc.
\item \verb|ACTIVATE_LSP| --- changes state from "Manufactured-Inactive" to "Manufactured" state. Also facilitates setup of single user mode. TODO: write about TPer states in the generic chapter. 
\item \verb|SET_PW| --- changes the password of the selected authority, using the admin password.
\item \verb|ACTIVATE_USR| --- enables specified user in the Opal tables.
\item \verb|REVERT_TPR| --- reverts the TPer to the manufactured state using admin password.
\item \verb|LR_SETUP| --- sets locking range position/locking enable
\item \verb|ADD_USR_TO_LR| --- adds a user to the LR ACE. ...\verb|l_state == OPAL_RW| means writing ace...  (TODO: they seem to set it to "\verb#(user_uid || user_uid)#"??? why? bug? -> MRE is \verb|opal_util_linux.c|, only used last assigned to LR can control it, does (not) work on all test disks
\item \verb|ENABLE_DISABLE_MBR| --- changes \verb|Enable| parameter of the \verb|MBRControl|. TODO: write about MBR in a generic chapter.
\item \verb|ERASE_LR| --- calls the erase method, 00 00 06 00 00 08 03, can't find it in opal and in core it's "reserved for SSC", ... it's in single user mode standard --- not only destroys data, also removes pin and user authority (for SUM).
\item \verb|SECURE_ERASE_LR| --- regenerate the data encryption key of a range to destroy the previous one.
\item \verb|PSID_REVERT_TPR| --- resets the TPer to the manufactured state using PSID.
\item \verb|MBR_DONE| --- changes \verb|Done| parameter of the \verb|MBRControl|.
\item \verb|WRITE_SHADOW_MBR| --- writes data into the MBR table.
\item \verb|GENERIC_TABLE_RW| --- reads a table or writes into a byte table. Neither object tables nor iteration are supported.
\end{itemize}

Currently, there is no documentation to be found for the ioctl requests for Opal functionality. The information in the previous list was acquired from our code analysis.

\subsection{Direct communication}

Alternative to the OPAL ioctl are disk controller ioctls. Depending on the disk protocol, a different way of passing the OPAL commands is required, such as using \verb|SG_IO| ioctl and \verb|sg_io_hdr_t| structure for SCSI disks or \verb|NVME_IOCTL_ADMIN_CMD| ioctl and \verb|nvme_admin_cmd| structure for NVMe disks. Using these structures, the OPAL commands described in chapter \ref{TODO} can be sent to the TPer. Compared to the OPAL ioctl this has the advantage of not being limited only to a subset of features that the OPAL ioctl implements, and instead being able to use every OPAL feature the device offers. This is not limited only to \dots (e.g. improve performance by using optional features such as concurency, etc, described earlier) \dots

Although this gives the user access to every feature of the OPAL disk, it also requires them not only to implement the command hand-over for each type of disk separately, but also to create the methods and parse the method results, both described in chapter \ref{TODO}, on their own.

TODO disk interface popsat\cite{NVME}

The commands that are called through the disk ioctl are called IF-RECV/IF-SEND in TCG Storage standards~\cite{tcg-storage-core}. These commands corresponds to several other commands in different interface specification. Some of them are the Security Receive/Send commands in NVMe~\cite{nvme-express-base-specification}, the TRUSTED RECEIVE/SEND commands in ATA~\cite{acs-3}, or the SECURITY PROTOCOL IN/OUT commands in SCSI~\cite{spc-4}.

