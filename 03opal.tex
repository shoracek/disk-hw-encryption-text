\chapter{TCG Opal 2.0}

TCG Opal Security Subsystem Class (SSC) 2.0 (hereinafter referred to simply as ``Opal standard'') is a specification for storage devices, aiming to provide confidentiality of stored data while the conforming disk is powered off~\cite{tcg-opal2}. It is one of the representatives of the self-encrypting drive approach to hardware disk encryption. 
% Developed in 2012 by Trusted Computing Group (TCG) as a successor of Opal 1.0.
Information for this chapter comes primarily from the Core standard~\cite{tcg-storage-core} and the Opal standard~\cite{tcg-opal2}.

% TODO: maybe split it into TCG storage and TCG opal chapters/sometghings.

In the following sections we shall firstly describe the specification and it's features and capabilities as described by the Core and Opal standards, afterwards we will focus on the mandatory features and requirements on Opal devices, and lastly we will describe the interface available on a Linux host. % TODO: maybe move this out of the chapter into separate chapter,,, with external tools... yea

\section{Structure of the standard}

The Opal standard is defined as a subsystem extending the TCG Storage Architecture Core Specification (hereinafter referred to simply as ``Core standard''). The Core standard~\cite{tcg-storage-core} specifies the core features and properties shared among several different types of storage security subsystems, that extend the core functionality by specifying additional features or define the set of mandatory features. Each of these subsystems is focused on a different use case. These subsystems are namely: \begin{itemize}
    \item Opal --- targeted at a corporate and personal usage. Described more closely in the rest of this chapter.
    \item Opalite --- simplified Opal. Does not mandate features such as locking ranges, decreases the minimal number of admin and user authorities, or additional DataStore tables~\cite{tcg-opalite}. % smaller datastore also, i think
    \item Pyrite --- encryption-less Opalite. Similar to Opalite, however it does not mandate encryption of data saved on disk, and instead may offer only logical access control~\cite{tcg-pyrite}.
    \item Ruby --- focused on data centers and server drives. Offers only global range encryption, weaker configuration of access control, no pre-boot authentication support~\cite{tcg-ruby}. Replacing the older Enterprise subsystem.
\end{itemize}

Other than the Core and Opal standards defining the fundamentals, there are defined also Feature Sets. These Feature Sets expand the standards with less fundamental features, such as Additional DataStore~\cite{TODO}, Block SID Authentication~\cite{TODO}, PSK Secure Messaging~\cite{TODO}, PSID~\cite{TODO}, or Single User Mode~\cite{TODO}. However, we will focus primarily on those that are mandatory in the Opal specification.

\section{Architecture}

The Core standard defines several parts of the trusted device. % TODO: maybe just mix into another section.

\subsection{Trusted Peripheral}

Trusted peripheral (TPer) is a device located on the disk that provides the security of the data on disk. A TPer consists of multiple Security Providers.

\subsection{Security Provider}

Security Provider (SP) is defined as a set of tables, methods and an access control. Each SP is derived from a set of templates. These templates define a set of the tables and methods, aimed at one functionality, subset of which the SP implements. The templates are described more closely in later chapter \ref{TODO}.
The Opal 2.0 standard defines that at least the Admin SP and Locking SP must be present in the TPer. The Admin SP tasked with administrating the TPer and other SPs, which may include creating new SPs, deleting existing SPs, or providing information about SPs. The Locking SP provides access to functionality such as managing locking ranges, locking the drive, or managing access control. Both of these SPs are described more closely in later chapter \ref{TODO}.

\section{Capability discovery}

In order to find out the properties and features of a particular device, there exists the so called Discovery process. This process is divided into three levels, each with different reported information and a different approach to access the information.

\subsection{Level 0 Discovery}

Level 0 Discovery provides basic information about the secure device, and is performed using only the IF-RECV and IF-SEND commands of the device. The information about the device is provided through feature descriptors. The presence of a feature descriptor header means that the feature is supported and the fields of the header describe the basic properties of that feature.

Some of the features described by these descriptors are the TPer Feature Descriptor (supported communication features such as ACK/NACK support, ComID management, buffer management, async communication, ...), Locking Feature Descriptor (whether disk is locked, etc.), Geometry Feature Descriptor (parameters of the disk, such as block size), Opal V1.0 Feature Descriptor, SingleUser Feature Descriptor (...), DataStore Feature Descriptor (size of the table), Opal 2.0 Feature Descriptor (base ComID, number of ComIDs, default pin, number of locking users/admins).

\subsection{Level 1 Discovery}

Level 1 Discovery provides capabilities of the communication channel, and is performed using the \verb|Properties| control session method. The Level 1 Discovery is used not only as a way for the host to find out the capabilities of the TPer, but to determine shared limits depending on the capabilities of both the TPer and the host, as host can also communicate its capabilities to the TPer.

The reported properties mandatory for Opal are:
\begin{itemize}
\item \verb|MaxMethods| --- maximum number of methods per received SubPacket.
\item \verb|MaxSubpackets| --- maximum number of SubPacket per received Packet.
\item \verb|MaxPacketSize| --- maximum size of a received Packet.
\item \verb|MaxPackets| --- maximum number of Packets per received ComPacket.
\item \verb|MaxComPacketSize| --- maximum size of a received ComPacket.
\item \verb|MaxResponseComPacketSize| --- maximum size of sent ComPacket.
\item \verb|MaxSessions| --- maximum number of active sessions.
\item \verb|MaxIndTokenSize| --- maximum size of an individual token.
\item \verb|MaxAuthentications| --- maximum possible authenticated authorities.
\item \verb|MaxTransactionLimit| --- maximum number of active transactions.
\item \verb|DefSessionTimeout| --- default length of session timeout in milliseconds.
\end{itemize}

There are also defined properties which are not required in Opal:
\begin{itemize}
\item \verb|MaxReadSessions| --- maximum number of reader sessions.
\item \verb|MaxAggTokenSize| --- maximum size of a combined token.
\item \verb|MaxSessionTimeout| --- maximum possible session timeout.
\item \verb|MinSessionTimeout| --- minimum possible session timeout.
\item \verb|DefTransTimeout| --- default transaction timeout.
\item \verb|MaxTransTimeout| --- maximum possible transaction timeout.
\item \verb|MinTransTimeout| --- minimum possible transaction timeout.
\item \verb|MaxComIDTime| --- timeout for ComID.
\item \verb|ContinuedTokens| --- support of continued tokens (token with size unknown at start, joins several tokens together).
\item \verb|SequenceNumbers| --- support of packet numbering (in Packet).
\item \verb|AckNak| --- support of ACK/NAK (in Packet) in communication.
\item \verb|Asynchronous| --- support of asynchronous communication.
\end{itemize}

Other than the defined properties, the level 1 Discovery process may also report other, vendor specific, properties.

\subsection{Level 2 Discovery}

Level 2 Discovery is the act of reading any table and is provided by the \verb|Get| method of an SP. This includes reading any table, such as the access control table or table of locking ranges. Some of the SPs' tables are described in later chapter~\ref{TODO}.

\section{Life cycle}

In order to keep information about the state and the working capacity of an SP, the concept life cycle is introduced. Life cycle describes the condition of an SP using one of several states. In the Core standard the following states are introduced: 
\begin{itemize}
\item ``nonexistent'' --- the SP does not exist. The SP might have been not created or already deleted.
\item ``issued'' --- the SP is in functional state.
\item ``issued-disabled'' --- the SP can only be authenticated to and enabled, all other functionality is disabled. An SP can be enabled and disabled using the SPInfo table of the corresponding SP.
\item ``issued-frozen'' --- no functionality of the SP is enabled. An SP can be frozen and unfrozen using the SP table of the Admin SP.
\item ``issued-disabled-frozen'' --- the SP is both disabled and frozen as described in the two previous items.
\item ``issued-failed'' --- SP is in fatal failure from which it cannot recover.
\end{itemize}

\subsection{SP Issuance}

SP issuance is the process of creation of a new SP from the Base Template and a set of other templates. This is achieved by calling the Admin SP's method IssueSP. After an SP is issued, it can be personalized. Personalization of an SP is the process of creating new tables (using method CreateTable), filling in existing tables (using methods CreateRow and Set), and setting up access control (using method AddACE).

\subsection{Life cycles in Opal}

Opal extends the states defined in the Core specification with a new set of life cycle states called ``manufactured'' --- ``manufactured-inactive'', ``manufactured'', ``manufactured-failed'', ``manufactured-disabled'', ``manufactured-disabled-frozen'', ``manufactured-disabled''. Each of these new states mirrors the corresponding ``issued'' state from the Core specification. Compared to the ``issued'' states, the ``manufactured'' states are created during manufacturing by the manufacturer, instead of during the subsequent use by the TPer owner. This is reflected by the fact that these manufactured SPs are not issued and deleted in Opal, instead they are activated and reverted. Activation automatizes the personalization using hardcoded, preconfigured values. Reverting SP maintains it's existence, returning it to the factory state instead. Note that this means that the ``manufactured-inactive'' corresponds to the ``nonexistent'' state.

\subsection{Taking ownership}

In order to take ownership of a TPer, the basic steps are:
1. initialize a session with the Admin SP as the Anybody authority, 
2. read the value in the \verb|C_PIN_MSID| row of \verb|C_PIN| table. This row has a static UID.
3. finish session
4. initialize a session with the Admin SP as the SID authority, using the PIN from \verb|C_PIN_MSID|.
5. change the PIN
6. finish session

however, note that the entire process of taking ownership is entirely optional and the device will work fine if it is skipped.

\section{Communication}

In order to send commands to the TPer or the SPs and receive responses, a specific protocol must be used. % TODO: Rephrase this...
% The protocol is split into several layers. The high level method calls, optional transactions, and sessions, which are carried by the interface commands.
% ((It's actually session, management, communication, TPer, interface, transport, in different part, fixup TODO.))
The communication protocol is split into several layers.
Starting from the lowest layer described in this thesis is the interface layer. The interface layer corresponds to the communication with the control unit of the disk. Depending on the disk interface there can be different security commands used and the Core standard abstracts these commands into only two commands: IF-RECV and IF-SEND. These commands facilitate all the communication necessary to communicate with the higher layers and are described more closely in section~\ref{TODO}.
Following layer is the TPer layer, a layer used primarily for allocation of ComID. Since on this layer the ComIDs are not used yet and so the state of the communication cannot be kept, the communication is only one way, each "session" consisting only of one command.
The Communication layer supports ComIDs and therefore allows two-way communication, and is used primarily for further ComID management, such as getting the state of ComID, or resetting state of ComID.
The Management layer facilitates establishing of session between an SP and the host. Since session number is not issued yet, this layer uses Control Sessions with a static session number.
The final layer is the Session layer. At this layer the session is already established and a communication can be performed using methods sent in packets. Most of the communication occurs in this layer with the use of method invocations.

\subsection{ComID}

One of the information required in order to send a command is the ComID, a number identifying the caller (e.g. application of the host). It ensures that responses to method calls will be received by the correct application, since there can be at one time multiple callers. 
There are three types of ComIDs: statically allocated ComID, dynamically allocated ComID and special ComIDs.
Statically allocated ComID can be acquired through the level 0 Discovery process. The Discovery process simply informs about the base ComID number and the number of of static ComIDs.
Dynamically allocated ComID can be acquired using the \verb|GET_COMID| command.
There exists also special ComIDs that are used to invoke the Level 0 Discovery or for ComID management.

Every ComID is in one of few states. These states are Inactive, Issued and Associated. If a ComID is in Issued or Associated state it is considered Active. After \verb|GET_COMID| a ComID becomes Issued and if a session is opened under it, it becomes Associated. Associated state becomes Inactive again once all sessions opened under it have been closed.

In Opal, statically allocated ComIDs are always Active.

\subsection{Packetization}

The communication in the last two layers is based on packets. There are three packet types that are nested, each packet type providing different service.
ComPacket is the outermost one, each ComPacket contains data for communication under only a single ComID. Each ComPacket can contain several Packets. The usage of Packet is intended for session reliability, specifying sequential numbers and the acknowledgements for them. Every Packet then consists of one or more SubPackets. Finally, SubPacket contains one or more method calls, or results of method calls. In case that the TPer supports buffer management, it may also use SubPackets for credit control, to inform the other party about remaining buffer amount.

\subsection{Methods}

The commands to TPer and SPs and their respective responses are transported in the form of methods. Methods are a sequence of tokens ...

The data of the SubPacket carry either the method call or method response. %can't there be something else?
These are expressed using a set of tokens in a specific order.

Each method invocation contains invoking UID, method UID, parameters, and status code list.
Invoking UID is used to identify which structure the method is invoked on. Other than tables and objects, there are also special invoking UIDs. These special invoking UIDs are "thisSP", signifying the SP with which the current session is open, and "SMUID", signifying the session manager. % TODO: define object as a row of a table
Method UID specifies the method to be called. Methods for "SMUID", managing session, cannot be found in the MethodID table.
There are two kinds of parameter: mandatory, identified by their position, and optional, used in a structure using an integer to identify the parameter, followed by the data of the parameter.

The method has the following structure: \\
\verb# CALL_TOKEN | INVOKING_UID | METHOD_UID# \\
\verb#| START_LIST_TOKEN | *ARGUMENTS* | END_LIST_TOKEN | END_OF_DATA_TOKEN# \\
\verb#| START_LIST_TOKEN | ERROR_VALUE | END_LIST_TOKEN | #

\begin{figure}
    \centering
\begin{tikzpicture}
% \draw (0,0) rectangle (2,2) node[pos=.5] {\verb|CALL_TOKEN|};
\node[draw] (1) at (0, 0) {\verb|CALL_TOKEN|};
\node[draw] (2) [right = 0cm of 1] {\verb|INVOKING_UID|};
\node[draw] (3) [right = 0cm of 2] {\verb|METHOD_UID|};
\node[draw] (4) at (0, -1) {\verb|START_LIST_TOKEN|};
\node[draw] (5) [right = 0cm of 4] {\verb|*ARGUMENTS*|};
\node[draw] (6) [right = 0cm of 5] {\verb|END_LIST_TOKEN|};
\node[draw] (7) [right = 0cm of 6] {\verb|END_OF_DATA_TOKEN|};
\node[draw] (8) at (0, -2) {\verb|START_LIST_TOKEN |};
\node[draw] (9) [right = 0cm of 8] {\verb|ERROR_VALUE|};
\node[draw] (10) [right = 0cm of 9] {\verb|00|};
\node[draw] (11) [right = 0cm of 10] {\verb|00|};
\node[draw] (12) [right = 0cm of 11] {\verb|END_LIST_TOKEN|};
\end{tikzpicture}    
\caption{Caption}
    \label{fig:my_label}
\end{figure}

Both the invocation of the method and the respond use the same general structure. Response method uses parameters to return data.
There are two types of arguments: mandatory arguments that all have to occur in the specified order, and optional arguments which can be left out and each of them is formatted as follows: \\ \verb# START_NAME_TOKEN | ARGUMENT_ID | ARGUMENT_VALUE | END_NAME_TOKEN #.

% object UID can be SP, table, row of table of a special object UID, SMUID --- session manager, used for session management



\subsection{Sessions}

Whereas ComID is used to differentiate the senders and, therefore, also the recipients of the methods, sessions are used for parallelization of communication of one such actor. Each session can have different authorized authorities and methods in process, but each session is still bound to one ComID. Since each ComID corresponds to one user, both the user and the TPer can send multiple methods calls or responses in one ComPacket.

TODO: not user or actor but host... e.g.  if it would be network storage, there can be some thingie that would split the communication 

Sessions use a system of readers-writer locks to enable several concurrently running read sessions without causing concurrency issues.

There are two types of sessions: regular session and control session (not going to care about control much, just between the TPer session manager and host session manager)...
Each ComID has one associated control session with a lifespan the same as the ComID. On the other hand, there can be multiple regular sessions.

Since the control session is used to establish a regular session with an SP, it is not connected to any SP. The control session is used for managing the regular sessions and, as such, provides methods such as:
\begin{itemize}
\item The \verb|properties| method enables to find a compromise between the communication capabilities of the host and the TPer or simply find the communication capabilities of the TPer. Using this method, the properties defined earlier in section~\ref{TODO}, such as maximum packet size, are established.
\item The StartSession and SyncSession methods provide a way to start an unencrypted session.
% \item The StartTrustedSession and SyncTrustedSession methods provide a way to start an encrypted session. They are used if needed after a StartSession/SyncSession invocation to finish protocols requiring two passes, such as ...
\item The StartTrustedSession and SyncTrustedSession methods provide a way to complete challenge-response authentication or to setup secure messaging/key exchange.
\item The CloseSession method used to close the session.
\end{itemize}

Each is identified by it's session number. The session number consists of the TPer session number selected by the TPer and the host session number selected by the host.




\subsubsection{Secure messaging}

Depending on the authorities used, it is also possible to start a secure messaging session, which provides message authenticity and/or confidentiality.
Authority's operation type decides the what trusted messaging is to be used. These are further described in the section~\ref{TODO}.
With other cases there is no secure messaging.
% *trustedsession - used with PuK, SymK, and HMAC authorities, secure messaging

% During session initialization, using the method StartSession, there are parameters for four parameters for authentication. Host/SPSigningAuthority for explicit authentication and Host/SPExchangeAuthority for implicit authentication. 

% not about trusted session anymore...: it is also possible to explicitly authenticate more than one authority, using the Authenticate method.

% TODO: talk about ComID lifecycle

\subsection{Transactions}

In order to facilitate safe execution of sequences of methods, the standard specifies transactions. Similarly to transactions in database systems, this feature enables one to revert effects of sequence of methods. This is done automatically in case the transaction is not finished, or if the transaction is manually aborted. However, not all the effects of methods are rolled back, such as logs. Nested transactions are supported, in which case the transaction is committed when the outermost transaction is finished.

\subsection{Memory structures}

In order to maintain the state of the device, tables are exclusively used. Tables are defined by their columns and each row is called an object.
Each SP contains a meta table called Table table which contains information about all the other tables in the SP.

Each template also defines its tables such as the key tables containing keys for different LRs.

% move probably under templates,,, or even better SP?

\section{Access Control}

In order to provide access to methods only to authorized actors, the standard also defines access control. The access control provides a way to allow access to methods of the SP only after the knowledge of a secret has been proved. Information required to verify knowledge of the secret is called a credential and is stored in one of the corresponding SP's credentials tables. Each SP may contain several credential tables, one for each type of credentials, such as a password,  an RSA key pair, or an AES key.

In order to support authentication of more than one user or require multiple users at once, access control rules are defined using Access Control Lists (ACL) containing Access Control Elements (ACE). Each entry in an ACL has an owner \dots. ACEs are Boolean expressions with inputs being authentication of authorities.

Each combination of method and object has defined ACL, which needs to be satisfied in order for the method to be invoked on the object. An ACL is satisfied once one of the ACEs contained within it is satisfied, where authenticated authority variables evaluate as true.


% Access control -- access control list consists of access control elements (boolean combination of authorities),,,
% each SP has AdminExch authority,,, 
% ACEs seem to be able to have different "owners",,,

% Other than an explicit authentication, an implicit authentication is also possible. In this authentication, the knowledge of secret is shown by successfully using encrypted communication channel. FACT CHECK

Other than explicit authentication, implicit authentication is also possible. Implicit authentication may be used with, e.g. the Exchange operation type where the session key by the SP is encrypted using a pre-shared key and returned to the host.


Authority may be authenticated either during session startup using parameters of the SessionStart method, or, if there is more than one authority, the additional authorities may be authenticated using Authenticate method. 
The Authenticate method authenticates only using explicit methods. 
In case Authenticate method is used to authenticate using a password, one invocation of the method with a password as the parameter is enough. In the case of challenge and response operation type (Sign, SymK, HMAC), the first invocation only specifies the authority to be authenticated and receives challenge in response, and the second invocation provides the response.


Each authority is an object in the authority table of the corresponding SP.
Each authority has a type which is either individual or class. Class authorities correspond to a set of authorities so that they can be easily assigned and changed in bulk.

Other than the Admin and User authorities, there is also a special SID authority. This authority represents the owner of the TPer, and, as such, provides access of admins extended by the capabilities related to TPer management, such as the ability to activate an SP or enabling Admin authorities. Compared to the other authorities, SID authority is shared between all SPs.
There is also the Anybody authority that provides access to public information on the TPer. No authentication is needed for this authority.

Other than PIN authentication, the Core standard also defines other approaches to authentication.

\subsection{Authorities}

Authorities are constructs used to represent an actor. Authorities are saved in the Authority table of every SP, provided by the Base template, and so are separate for each of the SP. Each authority is associated with one credential. This credential is an object from a table, depending on the type of the credential.

The Base template defines several optional authorities such as the Admin authorities, representing the owner of the SP, the Makers authorities, representing the manufacturer of the TPer, the Security Identifier authority (SID), representing the owner of the TPer, and TPer authorities, representing the TPer itself.
The Base template also defines a special authority Anybody without any credentials. This authority can be used in reading public info of the SPs or to take ownership of the TPer.

% Other templates also define other authorities. Both  such as the User authorities from Locking template, ...

Each authority has assigned one operation type. This operation type determines how can this authority be used to authenticate.
\begin{itemize}
    \item None --- 
    \item Password --- also called PIN, authenticated using a password as a parameter.
    \item Sign --- authenticated using challenge and response with asymmetric crypto.
    \item Exchange --- credentials of this authority are used to encrypt session key. Can be used only in StartSession.
    \item SymK --- authenticated using challenge and response with symmetric crypto.
    \item HMAC --- challenge and response with HMAC. E.g. during session startup the HMAC is sent in a parameter and contains the HMAC of the method excluding the HMAC parameter.
    \item TPerSign --- used to authenticate the TPer.
    \item TPerExchange --- 
\end{itemize}


\section{Templates}

Since SPs may share some of their functionality such as authentication, modification of tables, or retrieval of data from tables, there exists templates to define this shared functionality. Each of the SP then implements a subset of functionality of one or more templates. Since templates 

\subsection{Base template}

The Base template defines the shared subset required by every SP, and is therefore mandatory. The most important functionality that is defined by this template is access control and metadata.

\subsection{Admin template}

The Admin template is a template specific for the unique Admin SP. It provides access to methods managing the TPer.

\subsection{Crypto template}

Template providing methods providing cryptographic methods.

\subsection{Locking template}

Template specific for the unique Locking SP. Provides access to methods managing the lock state of the device, locking ranges...

\subsection{Clock template}

Template providing methods for indicating current time, measuring lag, and access to monotonic counter. 

\subsection{Log template}

Template providing methods for logging activity. The logging can be either carried out manually by an user (or an user application) or automatically by the TPer (as a result of invocations of methods of SPs containing this template, including invocations during read-only sessions). 
Only one system log table may exist on each SP, but multiple user log tables may be present on one SP.
The logs are saved on non-volatile storage, depending on the security setting of the table, they may be either buffered or be saved after each entry.

% TODO: how much are the logs preserved... will they get deleted with an SP?

\section{Admin SP}

% There are two so called Manufactured SPs, SPs which are 

The first of the Manufactured SPs is the Admin SP.
This SP holds information about the TPer and all the present SPs, it allows creation, deletion and general modification of the SPs.
It is ses base and admin template

unique

This SP is initialized as "manufactured", so that it can function as a starting point of TPer management.

\subsection{Methods}

Even though the templates from which the Admin SP consists define many more methods, the Opal standard mandates only the following ones:
\begin{itemize}
\item ``Next'' --- returns UIDs of objects in the table. Allows to specify the returned amount and the first UID.
\item ``GetACL'' --- returns the ACL of the method and object or method and table combination.
\item ``Get'' --- returns the value of the object or the contents of the byte table.
\item ``Set'' --- sets the value of the object or the contents of the byte table.
\item ``Authenticate'' --- performs an additional explicit authentication.
\item ``Revert'' --- reverts the SP referred to by the invoking ID to its initial state.
\item ``Activate'' --- activates the SP referred to by the invoking ID.
\item ``Random'' --- returns specified amount of random bytes.
\end{itemize}

\section{Locking SP}

Locking SP procures the disk encryption and the locking and unlocking associated with it. This means that it provides access to manipulation of locking ranges, key generation and ...

also unique

uses base and locking template

\subsection{Methods}
Some of the methods Opal mandates for Locking SP are shared (``Next'', ``GetACL'', ``Get'', ``Set'', ``Authenticate'', ``Random''), but there are also two new ones:
\begin{itemize}
\item ``GenKey'' --- regenerates a key or a credential. But, in the case of Opal, this method is mandated to be able to be used at least on the \verb|K_AES_*| DEK keys.
\item ``RevertSP'' --- reverts the Locking SP. Compared to ``Revert'' this method can revert only the SP to which the session is connected, allowing reverting without having access to Admin SP's Admin authority.
\end{itemize}

\subsection{Locking range}

The locking range feature gives the user a way to specify an LBA range on the disk that can be locked independently on the rest of the disk. Each locking range also has its own ACE to control who can lock and unlock the range. Because each LR is also encrypted using its own DEK, it is possible to regenerate new DEK for a single LR, discarding data of only one LR.


There also always exists a special range called the global locking range that covers any area on the disk that is not already covered by a regular locking range.

In order to control the access to the data on a disk covered by a specific locking range, the Locking table contains columns ReadLockEnabled, WriteLockEnabled, ReadLocked, and WriteLocked. The data inside the LR cannot be read when ReadLockEnabled and ReadLocked are both set to true. Otherwise, the LR range is locked, and the data cannot be read. Similarly, for writing and WriteLockEnabled and WriteLocked. The separation of the locking right into the LockEnabled and Locked column gives the ability to have separate ACE for the LockEnabled column, meaning that, for example, an admin can decide that the user can only lock reading for a specific LR but not writing. 

Each locking range also has a defined column LockOnReset containing a list of types of resets on which the LR gets locked. Although there are defined types such as HotPlug (which is not really defined anywhere, but we suspect that it corresponds to the ATA Hot Plug reset)... Opal requires the support of only the Power Cycle, Programmatic\footnote{Activated by TPER\_RESET, command on TPer layer.} and optionally Hardware Reset reset.

\subsection{Single User Mode}

In many cases, it might be desirable to prevent admins from accessing user data, even though the admins generally have more competence. 
The Single User Mode Feature Set~\cite{tcg-sum} defines a way to achieve this.
After activating Single User Mode, only a single User authority is capable of changing their authority object (this includes changing their PIN), changing the proprieties of LRs assigned to them (which includes the lock state of the LR) and generating new keys for those LRs.
The only actions available to the Admin authorities related to that LR are destructive actions.

% feature set that ``locks'' the admin out --- admin can do only destructive actions upon the locking range, and only the user can actually unlock it

\subsection{MBR shadowing}

This feature enables the disk to provide a fake master boot record (MBR). Instead of the MBR saved on the disk, the disk instead provides the shadow MBR saved in a table on bootup. The shadow MBR may contain software to enable the host to authenticate itself to the disk and unlock it. After the host is authenticated, the shadow MBR may be deactivated, and the regular disk data will be available again.

This feature is controlled using tables \verb|MBR|, a byte table containing the data to be presented while the shadowing is active, and \verb|ControlMBR|, an object table used to control the shadowing. Table \verb|ControlMBR| one row with columns \verb|Enable|, \verb|Done|, and \verb|MBRDoneOnReset|.
When \verb|Enable| is true and \verb|Done| is false, the shadowing is active, and the data from \verb|MBR| table can be read from the disk. The column \verb|MBRDoneOnReset| specifies a list of types of resets during which the \verb|Done| is set to false.

% TODO: specify reset types?

% The minimal maximum size of the shadow MBR seems to be 0x08000000 bytes ($\sim$134 MB).

% Move to locking SP.



\section{Opal SSC}

Even though the Core specification introduces many powerful and interesting features, this might increase the cost of design and manufacturing of a fully compliant device. To solve this problem, the Opal SSC determines only a small set of mandatory features, leaving most of the features optional. Together with the set of mandatory features it also states range limits of certain properties.

For access control, Opal is mandating only password authentication, this means that any other authentication such as implicit authentication of the host or any authentication of the TPer (and therefore also secure messaging) may not be available. For communication Opal requires only support of synchronous communication. For table management, Opal does not require support of creation or deletion of tables. Issuance of SPs is also not required, and Opal instead uses SPs preconfigured by the manufacturer.
Out of the previously mentioned SPs, Opal requires only that the Admin SP and the Locking SP are supported. Since SP issuance is not one of the mandatory features, the Locking SP may also be preconfigured by the manufacturer and be initially in the ``manufactured-inactive'' state. 

Due to the range limits specified in the Opal SSC, the following features also might not be available.
\begin{itemize}
\item Opal specifies that the device must be able to handle: at least one method per SubPacket, at least one SubPacket per Packet, and at least one Packet per ComPacket. This means that any ...
\item At least one active transaction per session, at least one active session per all the ComIDs and at least one ComID.
\end{itemize}
This means that an Opal-compliant device implementing only the required minimum will also not be able to provide any

But Opal does not only reduce the feature set from the Core standard, but also expands it with some extra feature sets. Even though the Core specification does not require the following feature sets, the Opal SSC requires them additionally.
% 2.10 Mandatory Feature Sets
% An Opal SSC compliant SD SHALL support the following TCG Storage Feature Sets:
% 1) Additional DataStore Tables, Opal SSC Feature Set (refer to [6]);
% 2) PSID, Opal SSC Feature Set (refer to [6]).
% 3) Block SID Authentication Feature Set (refer to [8])
\begin{itemize}
\item Physical Presence SID (PSID) is a special authority that is authorized to call only the Revert method. The PIN of this authority may not be found out using the interface of the disk, every one of our disk supplied this information on a label on the disk. This authority provides a way to reset the TPer into factory state even in case the SID PIN is lost.
\item DataStore tables are byte tables accessible for any use. Using the Activate method, the number of the DataStore tables with their sizes can be specified.
\item Block SID Authentication feature disables SID authority until device restart. Can be used by BIOS to protect somehow... this functionality seems kind of a reach...
\end{itemize}

From our experience with Opal disks, most of them did not implement more than the required minimum (TODO: fact recheck later on). Some of the tested disks, even though they were described by the vendor and/or manufacturer as Opal-compliant, did not implement every required feature set. Out of the 6 tested disks, only 2 implemented the required Block SID Authentication feature set. However, even those 2 implementing the feature set did not support the actual feature.

% TODO: maybe there is a difference between supporting the feature set and supporting the feature?

% 4.1.1 Block SID Authentication Feature (Feature Code = 0402)
% This feature descriptor SHALL be returned when the SD supports the Block SID Authentication Feature Set. The
% contents of the feature descriptor are defined in Table 2.


\section{Host-side implementation}

Other than using generic SED software introduced in chapter~\ref{TODO}, there are more low-level approaches to controlling Opal hardware available, which offer more control over the device. In this section, we will introduce two such approaches available in Linux systems.

\subsection{Linux ioctl}

Since version 4.11 the Linux kernel offers set of ioctl requests to facilitate control over an Opal disk~\cite{linux-opal-introduction-mail}. Although these ioctl requests offer a simple access to control of the disk, not every feature mandated by Opal is implemented. Some of the limitations are the following: 
\begin{itemize}
\item Access to only single admin authority and up to 9 user authorities.
\item No way to change SID PIN. This means that the authority representing the owner of the device, that often has control over the entire disk, is stuck with the PIN that was chosen during the taking of the ownership.  
\item no "write only" lock
\item no configuration of lockout, and no way to reset lockout --- doesn't matter since opal has read-only lockout values -> not implemented
\item The last mentioned is the missing  ability to read or write to object table rows or iterating tables. This prevents the possibility of replacing the missing features using a direct setting of values in a table.
\end{itemize}

The individual implemented ioctl requests for Opal functionality and their function as of Linux kernel 5.19 are:
\begin{itemize}
\item \verb|SAVE| --- adds a key for a locking range into a unlock list, so that it can be used after waking the disk up from suspend. To wake the disk up, exported symbol \verb|opal_unlock_from_suspend| can be used to unlock the disk with the saved data. Note that the data is saved only in the RAM, and so this cannot be used to wake the computer (??? What did i mean by this?... anyway this is entry point for some vulnerability analysis because it basically gives us back the cold boot attack!).
\item \verb|LOCK_UNLOCK| --- locks or unlocks reading or writing for the selected locking range.
\item \verb|TAKE_OWNERSHIP| --- changes the admin authority password from the default one to the selected one. TODO: write about initialisation of the TPer to the generic chapter, \verb|C_PIN_MSID| etc.
\item \verb|ACTIVATE_LSP| --- changes state from "Manufactured-Inactive" to "Manufactured" state. Also facilitates setup of single user mode. TODO: write about TPer states in the generic chapter. 
\item \verb|SET_PW| --- changes the password of the selected authority, using the admin password.
\item \verb|ACTIVATE_USR| --- enables specified user in the Opal tables.
\item \verb|REVERT_TPR| --- reverts the TPer to the manufactured state using admin password.
\item \verb|LR_SETUP| --- sets locking range position/locking enable
\item \verb|ADD_USR_TO_LR| --- sets the ACE for locking and unlocking to the designated user. Does not actually add a user, instead replaces any existing one by the new one. % adds a user to the LR ACE. ...\verb|l_state == OPAL_RW| means writing ace...  (TODO: they seem to set it to "\verb#(user_uid || user_uid)#"??? why? bug? -> MRE is \verb|opal_util_linux.c|, only used last assigned to LR can control it, does (not) work on all test disks
\item \verb|ENABLE_DISABLE_MBR| --- changes \verb|Enable| parameter of the \verb|MBRControl|. % TODO: write about MBR in a generic chapter.
\item \verb|ERASE_LR| --- calls the erase method, 00 00 06 00 00 08 03, can't find it in opal and in core it's "reserved for SSC", ... it's in single user mode standard --- not only destroys data, also removes pin and user authority (for SUM).
\item \verb|SECURE_ERASE_LR| --- regenerate the data encryption key of a range to destroy the previous one.
\item \verb|PSID_REVERT_TPR| --- resets the TPer to the manufactured state using PSID.
\item \verb|MBR_DONE| --- changes \verb|Done| parameter of the \verb|MBRControl|, only when both the Done and Enable parameters are enabled, MBR shadowing is active.
\item \verb|WRITE_SHADOW_MBR| --- writes data into the MBR table.
\item \verb|GENERIC_TABLE_RW| --- reads a byte table or writes into a byte table. Neither object tables nor iteration are supported.
\end{itemize}

Currently, there is no documentation to be found for the ioctl requests for Opal functionality. The information in the previous list was acquired from our code analysis.
Short program showcasing the usage of this interface can be seen in the appendix~\ref{TODO}.

\subsection{Direct communication}
\label{direct_communication_raw_ioctl}

Alternative to the Opal ioctl requests are disk controller ioctl requests. Depending on the disk protocol, a different way of passing the Opal commands is required, such as using \verb|SG_IO| ioctl and \verb|sg_io_hdr_t| structure for SCSI disks or \verb|NVME_IOCTL_ADMIN_CMD| ioctl and \verb|nvme_admin_cmd| structure for NVMe disks. Using these structures, the Opal commands described in chapter \ref{TODO} can be sent to the TPer. Compared to the Opal ioctl requests this has the advantage of not being limited only to a subset of features that the Opal ioctl requests implement, and instead being able to use every Opal feature the device offers. This is not limited only to \dots (e.g. improve performance by using optional features such as concurrency, etc, described earlier) \dots

Although this approach gives the user access to every feature of the Opal disk, it also requires them not only to implement the command hand-over for each type of disk separately, but also to create the methods and parse the method results, both described in chapter \ref{TODO}, on their own.

TODO disk interface popsat\cite{NVME}

The commands that are called through the disk controller ioctl requests are called IF-RECV/IF-SEND in TCG Storage standards~\cite{tcg-storage-core}. These commands corresponds to several other commands in different interface specification. Some of them are the Security Receive/Security Send commands in NVMe~\cite{nvme-express-base-specification}, the TRUSTED RECEIVE/TRUSTED SEND commands in ATA~\cite{acs-3}, or the SECURITY PROTOCOL IN/SECURITY PROTOCOL OUT commands in SCSI~\cite{spc-4}.


 