
\chapter{Existing tools}
\label{chapter_tools}

In order to give users the ability to manage their SED disks without the need to create their own programs to access existing interfaces, there exist several tools. 

In this chapter, we will look at several existing tools that allow one to manage the encryption of disks.

\section{Cryptsetup}

\emph{Cryptsetup}\footnote{\url{https://gitlab.com/cryptsetup/cryptsetup}} is a tool for disk encryption setup. Although this tool supports several formats and volumes, such as ..., all of them are software, and there is no hardware encryption support as of now.\todo{probably remove this since it does not support any hardware encryption,,, yet}

\section{hdparm}
 
The \emph{hdparm}\footnote{\url{https://sourceforge.net/projects/hdparm}} tool provides a command line interface to control parameters of ATA disks. Among others, this tool gives access to control ATA Security Feature Set.
The examples of SED-relevant commands for the functionality described in \ref{TODO} are:
\begin{itemize}
\item Enable the ATA Security Feature Set:\\ \verb|hdparm --security-set-pass pwd /dev/sda|
\item Disable ATA Security Feature Set:\\ \verb|hdparm --security-disable pwd /dev/sda|
\item Unlock the disk:\\ \verb|hdparm --security-unlock pwd /dev/sda|
\item Erase the disk:\\ \verb|hdparm --security-erase pwd /dev/sda|
\end{itemize}
Implicitly the user password is referred to in the commands, but \verb|--user-master| can be specified to select master or user password explicitly. While enabling the ATA Security Feature Set, it is also possible to use the \verb|--security-mode| option to choose between high and maximum security mode.
A command to lock the drive is missing because a drive with enabled ATA Security Feature Set is locked when powered off.

% ATA Security Feature Set: seems to be juts for ata and ata password, can it also work with our disks?

\section{sedutil}

\emph{sedutil}\footnote{\url{https://github.com/Drive-Trust-Alliance/sedutil}} is a tool for management of SED disks, maintained by the Drive Trust Alliance.
It currently supports the Enterprise and Opal SSCs (and additionally the remaining Pyrite, Opalite and Ruby SSCs in a fork of the project\footnote{\url{https://github.com/ChubbyAnt/sedutil}}) and NVMe and SATA interfaces.
Even though it is currently the largest open-source project to control SED disks, the code repository does not seem to be currently active.

This tool does not use the Linux Opal ioctl interface and instead uses the approach described in the subsection \ref{direct_communication_raw_ioctl}. This allows the tool not only to be multi-platform but also to use the Opal features in their entirety instead of only the subset introduced in the Opal ioctl interface.
% ... although there currently certain limits for e.g. having only one admin ...

% Provides functionality to:
The tool offers the following commands, grouped by their functionality:
\begin{itemize}
    \item Discovery: \begin{itemize}
\item \verb|isValidSED| --- lists SSCs supported by the selected disk.
\item \verb|scan| --- performs \verb|isValidSED| command on every disk in the system.
\item \verb|query| --- performs Level 0 and Level 1 Discovery on the selected disk.
\item \verb|printDefaultPassword| --- prints the MSID password.
    \end{itemize}
    
    \item TPer management: \begin{itemize}
\item \verb|initialSetup| --- takes ownership of the disk, and initializes Locking SP, global LR and shadow MBR.
\item \verb|setSIDPassword| --- changes the password of SID authority.
\item \verb|setAdmin1Pwd| --- changes the password of Locking SP's first admin authority. 
\item \verb|setPassword| --- changes the password of any supported Locking SP's authority.
    \end{itemize}
    
    \item Locking range management: \begin{itemize}
\item \verb|listLockingRanges| --- prints information about all LRs,
\item \verb|listLockingRange| --- prints information about a single LR,
\item \verb|rekeyLockingRange| --- regenerates the LR's key (destroying the data in the LR in the process)
\item \verb|setupLockingRange| --- sets the start and length of locking range,
\item \verb|setLockingRange| --- sets ReadLocked and WriteLock of the LR depending on the chosen configuration (read-write, read-only, or locked).
\item \verb|enableLockingRange| --- sets ReadLockEnabled and WriteLockEnabled of the LR. 
\item \verb|disableLockingRange| --- unsets ReadLockEnabled and WriteLockEnabled of the LR. 
    \end{itemize}
    
    \item Shadow MBR management: \begin{itemize}
\item \verb|setMBREnable| --- sets Enable column of the MBRControl table.
\item \verb|setMBRDone| --- sets Done column of the MBRControl table.
\item \verb|loadPBAimage| --- writes the contents of a file into the MBR table to be used as the shadow MBR.
    \end{itemize}
    
    \item Reverting the device: \begin{itemize}
\item \verb|revertTPer| --- reverts the TPer using the MSID password.
\item \verb|yesIreallywanttoERASEALLmydatausingthePSID| --- reverts the TPer using the PSID password.
\item \verb|revertNoErase| --- reverts only the Locking SP, keeping the global range data.
    \end{itemize}
    
    \item Enterprise-specific functionality\todo{actually find out what the bands are first, seem like just locking ranges, but hard to find source}: \begin{itemize}
\item \verb|setBandsEnabled| --- enables all locking ranges.
\item \verb|setBandEnabled| --- enables selected locking range.
\item \verb|eraseLockingRange| --- cryptographically erases data in specified locking range.
    \end{itemize}
\end{itemize}
% For Discovery there are commands 
% \verb|isValidSED| which lists supported SSCs by the selected disk,
% \verb|scan| which performs \verb|isValidSED| command on every disk in the system,
% and \verb|query| which performs Level 0 and Level 1 Discovery on the selected disk.
% Command \verb|printDefaultPassword| prints the MSID password.
% For management of the disk there are commands \verb|initialSetup| enabling to take ownership of the disk, 
% \verb|setSIDPassword| changing the password of SID authority,
% \verb|setAdmin1Pwd| changing password of Locking SP's first admin authority, 
% and \verb|setPassword| changing the password of any Locking SP's authority.

% For management of LRs there commands
% \verb|listLockingRanges| prints information about all LRs,
% \verb|listLockingRange| prints information about a single LR,
% \verb|rekeyLockingRange| regenerates the LR's key (destroying the data in the LR in the process)
% \verb|setupLockingRange| sets the start and length of locking range,
% \verb|setLockingRange| sets read locked and write locked of the LR, and
% \verb|disableLockingRange| and \verb|enableLockingRange| reading/writing locking enabled, 


% For controlling the shadow MBR there are commands \verb|setMBREnable| and \verb|setMBRDone| to set the Enable and Done columns respectively, and \verb|loadPBAimage| to write a file into the MBR table to be used as the shadow MBR.

% There are several commands for reverting the state of the device. Command
% \verb|revertTPer| reverts the TPer using the MSID password, 
% \verb|yesIreallywanttoERASEALLmydatausingthePSID| reverts the TPer using the PSID password, 
% and \verb|revertNoErase| reverts only the Locking SP, keeping the global range data.

% TCG Enterprise specific functionality, replaces LRs???? not really???, the use bands and bandmasters and erasemasters.
% \verb|setBandsEnabled|
% \verb|setBandEnabled|
% \verb|eraseLockingRange| 

\section{go-tcg-storage}

The \emph{go-tcg-storage}\footnote{\url{https://github.com/open-source-firmware/go-tcg-storage}} is a Go library, also providing CLI tools. Even though that compared to the previously introduced sedutil it is not as popular, it is currently in active development. It supports not only Opal 2.0 and Enterprise SSCs but also Ruby, the successor of Enterprise. It also, compared to sedutil, supports, in addition, the SAS interface.
Although it implements a CLI, its capabilities are compared to sedutil very limited.\todo{how}


% \todo{that does everything, and is actually supported.}
\todo{It has a few tools that let you do some things. It also supports more SSCs than others. Just found out about it, will need to look into it deeper and figure out why is it worse, so we won't look as bad.}
\todo{CLI: Was able to generate random numbers, but only for some of the disks. and very limited control over it}

\section{TCGstorageAPI}

Seagate's \emph{TCGstorageAPI}\footnote{\url{https://github.com/Seagate/TCGstorageAPI}} is library, that provides Python interface, and a CLI tool. Similarly to sedutil, it supports Opal and Enterprise SSCs.

\todo{Provides a Python library, written in c++, and a CLI...}

\todo{Has a bunch of dependencies, most importantly boost, which is pretty big...}

\todo{CLI: doesn't work with sdc "SED configuration is Unknown/Unsupported (Type Opal) - Exiting Script"
no random numbres}

\todo{offers test suite!!!}

\section{fscrypt - WIP}

\todo{probably rework into text about the tool for management instead?}
\todo{requires the filesystem to actually use the library In the following paragraphs, that should be redone, I am assuming ext4.}

\subsection{Usage}

As of now, block layer inline encryption is supported only by two file systems in Linux: ext4 and F2FS. 
In this part, we will focus only on the ext4 filesystem.

First of all, the inline encryption needs to be enabled in the kernel configuration. This means that the Linux kernel configuration option \verb|CONFIG_FS_ENCRYPTION_INLINE_CRYPT| needs to be enabled.
In order to start using the file system with encryption, it needs to be mounted with the option to specify the usage of inline encryption. 
\begin{lstlisting}[language=bash]
mount -t ext4 /dev/foo /mnt/foo -o inlinecrypt
\end{lstlisting}
It is not enough to specify the inline encryption flag. The encryption itself also must be enabled in the file system. On ext4 file systems, the encryption can be enabled after mounting like so:
\begin{lstlisting}[language=bash]
tune2fs -O encrypt /dev/foo
\end{lstlisting}
After this, fscrypt can be used as normal and it will use inline encryption for this filesystem.

In order to encrypt a folder using the kernel space fscrypt, the following must be done: an encryption key must be added and the encryption policy must be created. In C, this can be done the following way:
\begin{lstlisting}[language=c]
int fd = open(pathname, O_RDONLY | O_CLOEXEC);

// add a key
struct fscrypt_add_key_arg *key_request = calloc(1, sizeof(struct fscrypt_add_key_arg) + key_len);

key_request->key_spec.type = FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER;
key_request->key_id = 0;
key_request->raw_size = key_len;
memcpy(key_request->raw, key, key_len);
ioctl(fd, FS_IOC_ADD_ENCRYPTION_KEY, key_request);

// set a policy
struct fscrypt_policy_v2 policy_request = { 0 };

policy_request.version = FSCRYPT_POLICY_V2;
policy_request.contents_encryption_mode = FSCRYPT_MODE_AES_256_XTS;
policy_request.filenames_encryption_mode = FSCRYPT_MODE_AES_256_CTS;
policy_request.flags = FSCRYPT_POLICY_FLAGS_PAD_8 | FSCRYPT_POLICY_FLAGS_PAD_16 | FSCRYPT_POLICY_FLAGS_PAD_32;
memcpy(policy_request.master_key_identifier, key_request->key_spec.u.identifier, FSCRYPT_KEY_IDENTIFIER_SIZE);
ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, &policy_request);
\end{lstlisting}
This code sets up an encryption policy for the file specified by the pathname. 

\subsection{Implementation}
\todo{maybe remove completely?, doesn't seem to fit much...}

During mounting the ``inlinecrypt''/\verb|SB_INLINECRYPT|  flag is written into the \verb|super_block| structure.

It all starts in \verb|__ext4_new_inode|. This is the internal function used when creating new inodes, called by functions such as \verb|ext4_create| when creating a new file.

The function (if it is not inode used for large extended attributes?) calls \verb|fscrypt_prepare_new_inode|.

\verb|fscrypt_prepare_new_inode -> fscrypt_setup_encryption_info ->| \verb|setup_file_encryption_key ->  fscrypt_select_encryption_impl|

In \verb|fscrypt_select_encryption_impl| there is actually the only place where the \verb|SB_INLINECRYPT| flag is used.
... Calls \verb|blk_crypto_config_supported| to check the device's crypto profile.
Afterwards, \verb|fscrypt_select_encryption_impl| function sets the \verb|(fscrypt_info *)ci->ci_inlinecrypt|.

\verb|setup_per_mode_enc_key| then sets the \verb|(fscrypt_info *)ci->ci_enc_key|.

\paragraph{fscrypt - How does it work? - Usage}

The bio function is stored in \\ \verb|(struct bio *)bio->(struct bio_crypt_ctx *)bi_crypt_context|

Function \verb|fscrypt_set_bio_crypt_ctx| changes the file's bio to use inline encryption... simply calls the blk layer \verb|bio_crypt_set_ctx|.

Calling \verb|submit_bio| like normally ... \verb|__submit_bio| calls \verb|__blk_crypto_bio_prep|...

\blockquote{If the bio crypt context provided for the bio is supported by the underlying device's inline encryption hardware, do nothing.}

\verb|__blk_crypto_rq_bio_prep| however sets the context of the request to the one of the bio... 
After the bio prep  \verb|blk_mq_submit_bio| gets called (which calls \verb|blk_mq_bio_to_request|, and after that also \verb|blk_crypto_init_request->blk_crypto_get_keyslot| which updates the devices keyslot to contain the new key..., but does nothing if the device does not have keyslots)..... the info about the key to use then has to be acquired by the driver from \verb|request->|


Most important are probably structures \verb|blk_crypto_ll_ops| and \verb|blk_crypto_profile|... just two operations, program key and evict key. 



how to get crypto profile from outside..




Where does the hardware come to play?

\verb|ufshcd_exec_raw_upiu_cmd()->ufshcd_issue_devman_upiu_cmd()->ufshcd_prepare_req_desc_hdr()->ufshcd_prepare_req_desc_hdr_crypto()| sets the header with the correct keyslot.






\section{Proprietary solutions}

Some disks might provide their own software for their own proprietary hardware encryption. These are usually found separately on website or something, but some are provided as by the disk on an unecrypted partition.

